"""
Corrupt data by adding missing values to it with MNAR (missing not at random) pattern.
"""

# Created by Jun Wang <jwangfx@connect.ust.hk>
# License: GLP-v3

import numpy as np

try:
    import torch
except ImportError:
    pass


def mnar_x(X, offset=0, nan=0):
    """Create not-random missing values related to values themselves (MNAR-x case ot self-masking MNAR case). This case follows the setting in Ipsen et al.(" not-MIWAE: Deep Generative Modelling with Missing Not at Random Data")

    Parameters
    ----------
    X : array,
        Data vector. If X has any missing values, they should be numpy.nan.

    offset : float, in (0,1),
        the weight of standard deviation. In MNAR-x case, for each time serie, the values larger than the mean of each time serie plus offset*standard deviation will be missing

    nan : int/float, optional, default=0
        Value used to fill NaN values.

    Returns
    -------

    """
    if isinstance(X, list):
        X = np.asarray(X)

    if isinstance(X, np.ndarray):
        X_intact, X, missing_mask, indicating_mask = _mnar_x_numpy(X, offset, nan)
    elif isinstance(X, torch.Tensor):
        X_intact, X, missing_mask, indicating_mask = _mnar_x_torch(X, offset, nan)
    else:
        raise TypeError(
            "X must be type of list/numpy.ndarray/torch.Tensor, " f"but got {type(X)}"
        )
    return X_intact, X, missing_mask, indicating_mask


def _mnar_x_numpy(X, offset: float = 0, nan: float = 0):
    # clone X to ensure values of X out of this function not being affected
    X = np.copy(X)

    X_intact = np.copy(X)  # keep a copy of originally observed values in X_intact

    n_s, n_l, n_c = X.shape

    ori_mask = ~np.isnan(X)
    X = np.nan_to_num(X, nan=nan)
    X_intact = np.nan_to_num(X_intact, nan=nan)

    mask_sum = ori_mask.sum(1)
    mask_sum[mask_sum==0] = 1
    X_mean = np.repeat(((X*ori_mask).sum(1)/mask_sum).reshape(n_s,1,n_c), n_l, axis = 1)
    X_std = np.repeat(np.sqrt(np.square((X - X_mean)*ori_mask).sum(1)/mask_sum).reshape(n_s,1,n_c), n_l, axis = 1)

    mnar_missing_mask= np.zeros_like(X)
    mnar_missing_mask[X <= (X_mean +  offset*X_std)] = 1
    missing_mask = ori_mask * mnar_missing_mask
    indicating_mask = ori_mask - missing_mask
    X[missing_mask==0] = nan
    return X_intact, X, missing_mask, indicating_mask


def _mnar_x_torch(X, offset: float = 0, nan: float = 0):
    # clone X to ensure values of X out of this function not being affected
    X = torch.clone(X)

    X_intact = torch.clone(X)  # keep a copy of originally observed values in X_intact
    n_s, n_l, n_c = X.shape
    
    ori_mask = (~torch.isnan(X)).type(torch.float32)
    X = torch.nan_to_num(X, nan=nan)
    X_intact = torch.nan_to_num(X_intact, nan=nan)

    mask_sum = ori_mask.sum(1)
    mask_sum[mask_sum==0] = 1
    X_mean = ((X*ori_mask).sum(1)/mask_sum).reshape(n_s,1,n_c).repeat(1,n_l,1)
    X_std = (((X - X_mean)*ori_mask).pow(2).sum(1)/mask_sum).sqrt().reshape(n_s,1,n_c).repeat(1,n_l,1)

    mnar_missing_mask= torch.zeros_like(X)
    mnar_missing_mask[X <= (X_mean +  offset*X_std)] = 1
    missing_mask = ori_mask * mnar_missing_mask
    indicating_mask = ori_mask - missing_mask
    X[missing_mask==0] = nan
    return X_intact, X, missing_mask, indicating_mask


def mnar_t(X, cycle=20, pos = 10, scale = 3, nan=0):
    """Create not-random missing values related to temporal dynamics (MNAR-t case). In partical, the missingness is generated by a intensity function f(t) = exp(3*torch.sin(cycle*t + pos)). This case mainly follows the setting in https://hawkeslib.readthedocs.io/en/latest/tutorial.html.

    Parameters
    ----------
    X : array,
        Data vector. If X has any missing values, they should be numpy.nan.

    cycle : float,
        The cyele of the used intensity function

    pos : float,
        The displacement of the used intensity function

    scale : float,
        The scale number to control the missing rate 
    
    nan : int/float, optional, default=0
        Value used to fill NaN values.

    Returns
    -------

    """
    if isinstance(X, list):
        X = np.asarray(X)

    if isinstance(X, np.ndarray):
        X_intact, X, missing_mask, indicating_mask = _mnar_t_numpy(X, cycle, pos, scale, nan)
    elif isinstance(X, torch.Tensor):
        X_intact, X, missing_mask, indicating_mask = _mnar_t_torch(X, cycle, pos, scale, nan)
    else:
        raise TypeError(
            "X must be type of list/numpy.ndarray/torch.Tensor, " f"but got {type(X)}"
        )
    return X_intact, X, missing_mask, indicating_mask


def _mnar_t_numpy(X, cycle: float = 20, pos: float = 10, scale : float = 3, nan: float = 0):
    # clone X to ensure values of X out of this function not being affected
    X = np.copy(X)

    X_intact = np.copy(X)  # keep a copy of originally observed values in X_intact

    n_s, n_l, n_c = X.shape

    ori_mask = (~np.isnan(X)).astype(np.float32)
    X = np.nan_to_num(X, nan=nan)
    X_intact = np.nan_to_num(X_intact, nan=nan)

    ts = np.linspace(0, 1, n_l).reshape(1, n_l, 1)
    ts = np.repeat(ts, n_s, axis=0)
    ts = np.repeat(ts, n_c, axis=2)
    intensity = np.exp(3*np.sin(cycle*ts + pos))
    mnar_missing_mask = ((np.random.rand(n_s, n_l, n_c)*scale) < intensity)

    missing_mask = ori_mask * mnar_missing_mask
    indicating_mask = ori_mask - missing_mask
    X[missing_mask==0] = nan
    return X_intact, X, missing_mask, indicating_mask


def _mnar_t_torch(X, cycle: float = 20, pos: float = 10, scale : float = 3, nan: float = 0):
    # clone X to ensure values of X out of this function not being affected
    X = torch.clone(X)

    X_intact = torch.clone(X)  # keep a copy of originally observed values in X_intact
    n_s, n_l, n_c = X.shape
    
    ori_mask = (~torch.isnan(X)).type(torch.float32)
    X = torch.nan_to_num(X, nan=nan)
    X_intact = torch.nan_to_num(X_intact, nan=nan)

    ts = torch.linspace(0, 1, n_l).reshape(1, n_l, 1).repeat(n_s,1,n_c)
    intensity = torch.exp(3*torch.sin(cycle*ts + pos))
    mnar_missing_mask = ((torch.randn(X.size()).uniform_(0,1)*scale) < intensity)

    missing_mask = ori_mask * mnar_missing_mask
    indicating_mask = ori_mask - missing_mask
    X[missing_mask==0] = nan
    return X_intact, X, missing_mask, indicating_mask
